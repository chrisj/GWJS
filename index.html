<!DOCTYPE html>
<html>
<head>
    <script type="text/javascript" src="resources/createjs-2013.05.14.min.js"></script>

    <script type="text/javascript" src="jet.js"></script>
    <script type="text/javascript" src="bullet.js"></script>
    <script type="text/javascript" src="triangle.js"></script>

    <script>
    var KEYCODE_ENTER = 13;
    var KEYCODE_SPACE = 32;
    var KEYCODE_UP = 38;
    var KEYCODE_DOWN = 40;
    var KEYCODE_LEFT = 37;
    var KEYCODE_RIGHT = 39;
    var KEYCODE_W = 87;
    var KEYCODE_A = 65;
    var KEYCODE_S = 83;
    var KEYCODE_D = 68;

    var leftHeld;             //is the user holding a move left command
    var rightHeld;            //is the user holding a move right command
    var upHeld;               //is the user holding a move up command
    var downHeld;             //is the user holding a move down command

    var shootUpHeld;
    var shootDownHeld;
    var shootLeftHeld;
    var shootRightHeld;


    var stage;
    var gamepad
    var leftStickX;
    var leftStickY;
    var rightStickX;
    var rightStickY;

    var jet;
    var bullets = [];
    var enemies = [];

    //register key functions
    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;

    var canvasWidth;
    var canvasHeight;
    var gridColumns = 9;
    var gridRows = 5;

    var FPS = 30;

    var spawnEnemyTimer;
    var spawnEnemyTimerDefault = 3 * FPS;

    function init() {
        stage = new createjs.Stage("canvas");
        canvasWidth = window.stage.canvas.width;
        canvasHeight = window.stage.canvas.height;

        restart();

        jet = new Jet();
        jet.x = 100;
        jet.y = 100;

        stage.addChild(jet);

        createjs.Ticker.useRAF = true; // learn more about this
        createjs.Ticker.setFPS(FPS);
        createjs.Ticker.addEventListener("tick", tick);
    }

    function restart() {
        stage.removeAllChildren();

        drawGrid();

        leftStickX = 0;
        leftStickY = 0;
        rightStickX = 0;
        rihtStickY = 0;
        spawnEnemyTimer = spawnEnemyTimerDefault;
    }

    function tick(event) {
        // input
        checkGamepad();

        // update game objects
        updateJet();
        updateBullets();
        updateEnemies();

        // draw
        stage.update();
    }

    // Returns a random integer between min and max
    // Using Math.round() will give you a non-uniform distribution!
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function spawnEnemy(event) {
        var triangle = new Triangle(getRandomInt(0, canvasWidth), getRandomInt(0, canvasHeight));
        stage.addChild(triangle);
        enemies.push(triangle);
    }

    function updateJet(event) {
        if (distanceToOrigin(leftStickX, leftStickY) > .5) {
            jet.x += leftStickX * 15;
            jet.y += leftStickY * 15;
        }
    }

    function updateBullets(event) {
        // add new bullet if needed
        if (distanceToOrigin(rightStickX, rightStickY) > .3) {
            var newBullet = new Bullet(jet.x, jet.y, rightStickX * 20, rightStickY * 20);
            bullets.push(newBullet);
            stage.addChild(newBullet);
        }

        // move and remove bullets
        bullets.filter(function(bullet) {
            bullet.tick(event);

            if(!bullet.inBounds()){
                stage.removeChild(bullet);
                return true;
            }
            return false;
        });
    }

    function updateEnemies(event) {
        // spawn enemies
        if (spawnEnemyTimer == 0) {
            spawnEnemy();
            spawnEnemyTimer = spawnEnemyTimerDefault;
        } else {
            spawnEnemyTimer -= 1;
        }

        // move enemies
        for(var i = 0; i < enemies.length; i++){
            enemies[i].tick(event);
        }
    }

    function checkGamepad() {
        var gamepads = (navigator.webkitGetGamepads && navigator.webkitGetGamepads()) || navigator.webkitGamepads;

        var debug = '';
        if (gamepads.length) {
            pad = gamepads[0]

            if (pad && pad.axes.length == 4) {
                leftStickX = pad.axes[0];
                leftStickY = pad.axes[1];
                rightStickX = pad.axes[2];
                rightStickY = pad.axes[3];
            } else {
                // resort to keyboard input

                    leftStickX = 0;
                    leftStickY = 0;
                    rightStickX = 0;
                    rightStickY = 0;

                if (upHeld) {
                    leftStickY -= 1;
                }
                if (downHeld) {
                    leftStickY += 1;
                }
                if (leftHeld) {
                    leftStickX -= 1;
                }
                if (rightHeld) {
                    leftStickX += 1;
                }

                if (distanceToOrigin(leftStickX, leftStickY) > 1) {
                    leftStickX *= Math.sqrt(1/2);
                    leftStickY *= Math.sqrt(1/2);
                }


                if (shootUpHeld) {
                    rightStickY -= 1;
                }
                if (shootDownHeld) {
                    rightStickY += 1;
                }
                if (shootLeftHeld) {
                    rightStickX -= 1;
                }
                if (shootRightHeld) {
                    rightStickX += 1;
                }

                if (distanceToOrigin(rightStickX, rightStickY) > 1) {
                    rightStickX *= Math.sqrt(1/2);
                    rightStickY *= Math.sqrt(1/2);
                }
            }

            debug = 'LeftStick (' + leftStickX + ", " + leftStickY + ")<br/>";
            debug += 'RightStick (' + rightStickX + ", " + rightStickY + ")<br/>";

            document.getElementById("debug").innerHTML = debug;
        }
    }

    function drawGrid() {
        var grid = new createjs.Shape();
        var g = grid.graphics;

        var pixelsPerGridWidth = canvasWidth / gridColumns;
        var pixelsPerGridHeight = canvasHeight / gridRows;

        // set grid style
        g.setStrokeStyle(8, "round");
        g.beginStroke("#000000");

        // set grid lines
        g.moveTo(0,0).lineTo(canvasWidth, canvasHeight);
        g.lineTo(canvasWidth, 0);


        for(var i = 0; i < gridColumns; i++) {
            g.moveTo(pixelsPerGridWidth * i, 0).lineTo(pixelsPerGridWidth * i, canvasHeight);
        }

        // draw grid
        g.endStroke();
        stage.addChild(grid);
    }

    //allow for WASD and arrow control scheme
    function handleKeyDown(e) {
        //cross browser issues exist
        if(!e){ var e = window.event; }
        switch(e.keyCode) {
            case KEYCODE_W:     upHeld = true; return false;
            case KEYCODE_A:     leftHeld = true; return false;
            case KEYCODE_S:     downHeld = true; return false;
            case KEYCODE_D:     rightHeld = true; return false;
            case KEYCODE_UP:    shootUpHeld = true; return false;
            case KEYCODE_DOWN:  shootDownHeld = true; return false;
            case KEYCODE_LEFT:  shootLeftHeld = true; return false;
            case KEYCODE_RIGHT: shootRightHeld = true; return false;
        }
    }

    function handleKeyUp(e) {
        //cross browser issues exist
        if(!e){ var e = window.event; }
        switch(e.keyCode) {
            case KEYCODE_W:     upHeld = false; break;
            case KEYCODE_A:     leftHeld = false; break;
            case KEYCODE_S:     downHeld = false; break;
            case KEYCODE_D:     rightHeld = false; break;
            case KEYCODE_UP:    shootUpHeld = false; break;
            case KEYCODE_DOWN:  shootDownHeld = false; break;
            case KEYCODE_LEFT:  shootLeftHeld = false; break;
            case KEYCODE_RIGHT: shootRightHeld = false; break;
        }
    }

    function distanceToOrigin(x, y) {
        return Math.sqrt((x * x) + (y * y))
    }

    </script>
</head>
<body onLoad="init();">
    <canvas id="canvas" width="900" height="500"></canvas>
    <div id="debug"></div>
</body>
</html>